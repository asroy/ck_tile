# SPDX-License-Identifier: MIT
# Copyright (c) 2018-2024, Advanced Micro Devices, Inc. All rights reserved.
# generate kernel instances to speed up compilation

import argparse
import itertools
from pathlib import Path
from typing import List, Optional
from dataclasses import dataclass

DTYPE_MAP = {
    "fp16": "ck::half_t",
    "bf16": "ck::bhalf_t",
    "fp8" : "ck::f8_t"
}

MASK_MAP = {
    "no" : "FmhaMasks::NoMask",
    "causal" : "FmhaMasks::CausalMask",
    "generic" : "FmhaMasks::GenericMask"
}

MODE_MAP = {
    "batch" : "false",
    "group" : "true"
}

LAYOUT_MAP = {
    "row" : "ck::tensor_layout::gemm::RowMajor",
    "col" : "ck::tensor_layout::gemm::ColumnMajor"
}

PIPELINE_MAP = {
    "qr" : "ck::tile_program::block::BlockFmhaPipelineQRKSVS",
    "qr_fp8" : "ck::tile_program::block::BlockFmhaPipelineQRKSVSFp8",
    "qr_async" : "ck::tile_program::block::BlockFmhaPipelineQRKSVSAsync",
    "qr_async_fp8" : "ck::tile_program::block::BlockFmhaPipelineQRKSVSAsyncFp8"
}

BOOL_MAP = {
    "t" : "true",
    "f" : "false"
}

# HDIMS = [32, 64, 128]
HDIMS = [128]
LSE_MAP = {
    "no" : "false",
    "store" : "true"
}

HDIMS = [32, 64, 128]
DIRECTIONS = ["fwd"]
GEN_DIR = ""

CREDIT = """// SPDX-License-Identifier: MIT
// Copyright (c) 2018-2024, Advanced Micro Devices, Inc. All rights reserved.\n
"""

KERNEL_FLAT_HEADER = """// auto generated by generate_kernels.py
#include "fmha_fwd.hpp"

"""
KERNEL_FLAT_IMPL_TEMPLATE_FWD="""
using fmha_dtype_{F_idx} = {F_dtype};

using fmha_block_tile_{F_idx} = ck::Sequence<{F_bm0}, {F_bn0}, {F_bk0}, {F_bn1}, {F_bk1}, {F_bk0blen}>;
using fmha_block_warps_{F_idx} = ck::Sequence<{F_rm}, {F_rn}, {F_rk}>;
using fmha_warp_tile_{F_idx} = ck::Sequence<{F_wm}, {F_wn}, {F_wk}>;

using fmha_shape_{F_idx} = ck::tile_program::TileFmhaShape<fmha_block_tile_{F_idx},
                                      fmha_block_warps_{F_idx},
                                      fmha_warp_tile_{F_idx},
                                      fmha_block_warps_{F_idx},
                                      fmha_warp_tile_{F_idx},
                                      {F_vlayout}>;

using fmha_trait_{F_idx} = ck::tile_program::TileFmhaTraits<{F_m0pad},
                                                    {F_m0k1pad},
                                                    {F_k0n1pad},
                                                    {F_bias},
                                                    {F_lse},
                                                    {F_occupancy}>;
using fmha_mask_{F_idx} = {F_mask};

using fmha_pipeline_problem_{F_idx} = ck::tile_program::block::BlockFmhaPipelineProblem<
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::QDataType,
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::KDataType,
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::VDataType,
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::SaccDataType,
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::SMPLComputeDataType,
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::BiasDataType,
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::PDataType,
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::OaccDataType,
    typename FmhaFwdTypeConfig<fmha_dtype_{F_idx}>::ODataType,
    fmha_shape_{F_idx},
    {F_mode},
    fmha_mask_{F_idx},
    fmha_trait_{F_idx}>;

using fmha_pipeline_{F_idx} = {F_pipeline}<
    fmha_pipeline_problem_{F_idx}>;

using fmha_epilogue_{F_idx} =
    FmhaFwdEpilogue<FmhaFwdEpilogueProblem<typename FmhaFwdTypeConfig<{F_dtype}>::OaccDataType,
                                           typename FmhaFwdTypeConfig<{F_dtype}>::ODataType>>;

using fmha_kernel_{F_idx} = 
    FmhaFwdKernel<FmhaFwdTilePartitioner<fmha_shape_{F_idx}>,
                  fmha_pipeline_{F_idx},
                  fmha_epilogue_{F_idx}>;

using trait_{F_idx} = fmha_fwd_traits<{F_hdim}, {F_dtype}, {F_mode}, fmha_mask_{F_idx}, {F_bias}>;

template<>
float fmha_fwd_<trait_{F_idx}>(const StreamConfig& s, fmha_fwd_args a)
{{
    using k_ = fmha_kernel_{F_idx};
    auto [kargs, grids] = fmha_fwd_create_kargs_and_grids<k_>(a);
    constexpr dim3 blocks             = k_::BlockSize();
    constexpr ck::index_t kBlockPerCu = k_::kBlockPerCu;
    return launch_kernel<blocks.x, kBlockPerCu>(s, k_{{}}, grids, blocks, 0, kargs);
}}
"""

KERNEL_IMPL_TEMPLATE_FWD = """// auto generated by generate_kernels.py
#include "fmha_fwd.hpp"

using kernel_0 = FmhaFwdKernelSelector<{HDIM}, {DTYPE}, {MODE}, {MASK}, true, {LSE}>;
FMHA_FWD_KERNEL_DEFINE(kernel_0)
using kernel_1 = FmhaFwdKernelSelector<{HDIM}, {DTYPE}, {MODE}, {MASK}, false, {LSE}>;
FMHA_FWD_KERNEL_DEFINE(kernel_1)
"""

@dataclass
class FmhaFwdTileSize:
    F_bm0       : int  # tile size along q seqlen (block size)
    F_bn0       : int  # tile size along qk seqlen
    F_bk0       : int  # tile size along qk gemm unroll
    F_bn1       : int  # tile size along v head_dim
    F_bk1       : int  # tile size along kv gemm unroll
    F_bk0blen   : int  # total length of K0, used for pipeline that need load Q at once (or repeately load Q as a whole tile)
    F_rm        : int  # number of warps along q seqlen (block warps)
    F_rn        : int  # number of warps along k seqlen(not used)
    F_rk        : int  # number of warps along gemm-k(not used)
    F_wm        : int  # warp size along m (warp size)
    F_wn        : int  # warp size along n
    F_wk        : int  # warp size along k
    F_occupancy : int  # occupancy
    @property
    def name(self) -> str:
    return f"b{self.F_bm0}x{self.F_bn0}x{self.F_bk0}x{self.F_bn0}x{self.F_bk1}x{self.F_bk0blen}" +\
        f"_r{self.F_rm}x{self.F_rn}x{self.F_rk}_w{self.F_wm}x{self.F_wn}x{self.F_wk}_o{self.F_occupancy}"

# this is current supported tile size.
def get_fmha_fwd_tile_dict_from_dtype(dtype : str) -> Optional[Dict]:
    if dtype == 'fp16' or dtype == 'bf16':
        return {
            '32'  : FmhaFwdTileSize(128, 64, 16, 32, 32, 32,     2, 1, 1, 32, 32, 16, 2),
            '64'  : FmhaFwdTileSize(128, 64, 32, 64, 32, 64,     4, 1, 1, 32, 32, 16, 3),
            '128' : FmhaFwdTileSize(128, 128, 32, 128, 32, 128,  4, 1, 1, 32, 32, 16, 2)
        }
    else if dtype == 'fp8' or dtype == 'bf8':
        return {
            '128' : FmhaFwdTileSize(128, 128, 32, 128, 32, 128,  4, 1, 1, 32, 32, 32, 2)
        }
    else:
        return None

def get_fmha_fwd_tile_size(dtype : str, hdim : int) -> Optional[FmhaFwdTileSize]:
    d = get_fmha_fwd_tile_dict_from_dtype(dtype)
    if d is None:
        return None
    if hdim in d.keys():
        return d[hdim]
    else:
        return None

@dataclass
class FmhaFwdKernel:
    direction   : str

    F_idx       : int  # this is not a tunable, but a counter to differentiate symbol    
    F_hdim      : int  # hdim
    F_dtype     : str  # data type
    F_tile      : FmhaFwdTileSize
    F_vlayout   : str  # row/col
    F_m0pad     : str  # true/false
    F_m0k1pad   : str  # 
    F_k0n1pad   : str  # 
    F_bias      : str  # true/false
    F_lse       : str  #
    F_mask      : str  # value from MASK_MAP
    F_mode      : str  # value from MODE_MAP
    F_pipeline  : str  # value from PIPIELINE_MAP

    @property
    def template(self) -> str:
        return KERNEL_FLAT_HEADER + \
            KERNEL_FLAT_IMPL_TEMPLATE_FWD.format(
            F_idx       = self.F_idx,
            F_hdim      = self.F_hdim,
            F_dtype     = DTYPE_MAP[self.F_dtype],
            F_bm0       = self.F_tile.F_bm0,
            F_bn0       = self.F_tile.F_bn0,
            F_bk0       = self.F_tile.F_bk0,
            F_bn1       = self.F_tile.F_bn1,
            F_bk1       = self.F_tile.F_bk1,
            F_bk0blen   = self.F_tile.F_bk0blen,
            F_rm        = self.F_tile.F_rm,
            F_rn        = self.F_tile.F_rn,
            F_rk        = self.F_tile.F_rk,
            F_wm        = self.F_tile.F_wm,
            F_wn        = self.F_tile.F_wn,
            F_wk        = self.F_tile.F_wk,
            F_vlayout   = LAYOUT_MAP[self.F_vlayout],
            F_m0pad     = BOOL_MAP[self.F_m0pad],
            F_m0k1pad   = BOOL_MAP[self.F_m0k1pad],
            F_k0n1pad   = BOOL_MAP[self.F_k0n1pad],
            F_bias      = BOOL_MAP[self.F_bias],
            F_lse       = self.F_lse,
            F_occupancy = self.F_tile.F_occupancy ,
            F_mask      = MASK_MAP[self.F_mask],
            F_mode      = MODE_MAP[self.F_mode],
            F_pipeline  = PIPELINE_MAP[self.F_pipeline])

    @property
    def name(self) -> str:
        # TODO: we don't encode idx here
        return f"fmha_{self.direction}_d{self.F_hdim}_{self.F_dtype}_{self.F_mode}_" + self.F_tile.name + f"v{self.F_vlayout[0]}" +\
            f"_p{BOOL_MAP[self.F_m0pad][0]}{BOOL_MAP[self.F_m0k1pad][0]}{BOOL_MAP[self.F_k0n1pad][0]}_{BOOL_MAP[self.F_bias][0]}"  +\
            f"_m{self.F_mask[0]}_l{BOOL_MAP[self.lse][0]}_{self.F_pipeline}"

    @property
    def filename(self) -> str:
        return self.name + ".cpp"

@dataclass
class KernelFlat:
    direction: str
    hdim: int
    f_data: FmhaFwdKernel

    @property
    def template(self) -> str:
        return self.f_data.template

    @property
    def filename(self) -> str:
        return f"fmha_{self.direction}_" + self.f_data.name + ".cpp"

@dataclass
class Kernel:
    direction: str
    hdim: int
    dtype: str
    mode : str
    mask : str
    lse : str

    @property
    def template(self) -> str:
        if self.direction == "fwd":
            return KERNEL_IMPL_TEMPLATE_FWD.format(
                HDIM=self.hdim, DTYPE=DTYPE_MAP[self.dtype],
                MODE=MODE_MAP[self.mode], MASK=MASK_MAP[self.mask],
                LSE=LSE_MAP[self.lse])

    @property
    def filename(self) -> str:
        return f"fmha_{self.direction}_hdim{self.hdim}_{self.dtype}_{self.mode}_{self.mask}_mask_{self.lse}_lse.cpp"

def get_all_kernels() -> List[Kernel]:
    for direction, hdim, dtype, mode, mask, lse in itertools.product(DIRECTIONS, HDIMS, DTYPE_MAP.keys(), MODE_MAP.keys(), MASK_MAP.keys(), LSE_MAP.keys()):
        if dtype == 'fp8':
            continue
        yield Kernel(direction=direction, hdim=hdim, dtype=dtype, mode=mode, mask=mask, lse=lse)

    for dtype in DTYPE_MAP.keys():
        d = get_fmha_fwd_tile_dict_from_dtype(dtype)
        if d == None:
            continue
        

    #TODO: ugly
    for mode, mask, bias in itertools.product(MODE_MAP.keys(), MASK_MAP.keys(), ["t", "f"]):
        #                                           idx dtype  block_tile                    warps    warp size    V      pad          bias ocpy  m
        #  yield KernelFlat("fwd",  32, FmhaFwdKernel(0,  "fp8", 128,  64,  16,  32,  32,  32, 2, 1, 1, 32, 32, 16, "col", "f", "f", "f", "f", 2   ,mask, mode, "qr_async_fp8"))
        # yield KernelFlat("fwd",  64, FmhaFwdKernel(0,  "fp8", 128,  64,  32,  64,  32,  64, 4, 1, 1, 32, 32, 16, "col", "f", "f", "f", "f", 2   ,mask, mode, "qr_async_fp8"))
        yield KernelFlat("fwd", 128, FmhaFwdKernel(0,  128, "fp8", 128, 128,  32, 128,  32, 128, 4, 1, 1, 32, 32, 32, "col", "f", "f", "f", bias , 2   ,mask, mode, "qr_fp8"))


def write_single_kernel(kernel: Kernel, autogen_dir: Path) -> None:
    (autogen_dir / kernel.filename).write_text(CREDIT + kernel.template)

def write_kernels(output_dir: Optional[str]) -> None:
    if output_dir is None:
        output_dir = Path(__file__).parent
    else:
        output_dir = Path(output_dir) / GEN_DIR

    output_dir.mkdir(parents=True, exist_ok=True)
    for kernel in get_all_kernels():
        write_single_kernel(kernel, output_dir)

def list_kernels(to_file: Optional[str]) -> None:
    assert to_file is not None
    file_path = Path(to_file)
    with file_path.open('a') as f:
        for kernel in get_all_kernels():
            f.write(str(file_path.parent / GEN_DIR / kernel.filename) + "\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="generate_kernels",
        description="gen kernels for CK fmha kernel instances",
    )
    parser.add_argument(
        "-o",
        "--output_dir",
        required=False,
        help="Where to generate the kernels "
        " will default to the current directory ",
    )
    parser.add_argument(
        "-l",
        "--list_kernels",
        required=False,
        help="list all the kernels to a file"
    )
    args = parser.parse_args()
    if args.list_kernels is not None:
        list_kernels(args.list_kernels)
    else:
        write_kernels(args.output_dir)
